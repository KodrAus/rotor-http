use std::io::Write;
use std::any::Any;

use hyper::status::StatusCode;
use hyper::header::{Header, HeaderFormat, HeaderFormatter};
use hyper::header::{ContentLength, TransferEncoding, Encoding};

use super::{Response, ResponseImpl};


quick_error! {
    #[derive(Debug)]
    pub enum HeaderError {
        DuplicateContentLength {
            description("Content-Length is added twice")
        }
        DuplicateTransferEncoding {
            description("Transfer-Encoding is added twice")
        }
        TransferEncodingAfterContentLength {
            description("Transfer encoding added when Content-Length is \
                already specified")
        }
        ContentLengthAfterTransferEncoding {
            description("Content-Length added after Transfer-Encoding")
        }
        UnknownTransferEncoding {
            description("Unknown Transfer-Encoding, only chunked is supported")
        }
        CantDetermineBodySize {
            description("Neither Content-Length nor TransferEncoding \
                is present in the headers")
        }
    }
}


/// This response is returned when Response is dropping without writing
/// anything to the buffer. In any real scenario this page must never appear.
/// If it is, this probably means there is a bug somewhere. For example,
/// emit_error_page has returned without creating a real error response.
pub const NOT_IMPLEMENTED_HEAD: &'static str = concat!(
    "HTTP/1.0 501 Not Implemented\r\n",
    "Content-Type: text/plain\r\n",
    "Content-Length: 22\r\n",
    "\r\n",
    "501 Not Implemented\r\n",
    );
pub const NOT_IMPLEMENTED: &'static str = concat!(
    "HTTP/1.0 501 Not Implemented\r\n",
    "Content-Type: text/plain\r\n",
    "Content-Length: 22\r\n",
    "\r\n",
    );


impl<'a> Response<'a> {
    /// Write status line
    ///
    /// This puts status line into a buffer immediately. If you don't
    /// continue with request it will be sent to the network shortly.
    ///
    /// # Panics
    ///
    /// When status line is already written. It's expected that your request
    /// handler state machine will never call the method twice.
    ///
    /// When status is 100x
    pub fn status(&mut self, code: StatusCode) {
        use hyper::status::StatusCode::*;
        use super::ResponseBody::*;
        use super::ResponseImpl::*;
        match self.1 {
            Start { version, mut body } => {
                // Note we don't expect code 100 and 102 here, but
                // we don't assert on that for now. The point is that
                // responses 100 and 102 are interim. 100 is generated by
                // rotor-http itself and 102 should probably too. Or we
                // will have a special method in request for it, because
                // request will contain another (real) response status here.
                //
                // TODO(tailhook) should we assert?
                //
                write!(self.0, "{:03} {} {}\r\n", code,
                    code.canonical_reason().unwrap_or("Unknown"),
                    version).unwrap();
                if matches!(code, SwitchingProtocols|NoContent) {
                    body = Denied;
                } else if body == Normal && code == NotModified {
                    body = Ignored;
                }
                self.1 = Headers { body: body,
                                   content_length: None, chunked: false };
            }
            ref state => {
                panic!("Called status() method on response in a state {:?}",
                       state)
            }
        }
    }
    // Add header to response
    //
    // Header is written into the output buffer immediately. And is sent
    // as soon as the next loop iteration
    //
    // Fails when invalid combination of headers is encountered. Note we
    // don't validate all the headers but only security-related ones like
    // double content-length and content-length with the combination of
    // transfer-encoding.
    //
    // We return Result here to make implementing proxies easier. In the
    // application handler it's okay to unwrap the result and to get
    // a meaningful panic (that is basically an assertion).
    //
    // # Panics
    //
    // * Panics when add_header is called in the wrong state.
    // * Panics on unsupported transfer encoding
    //
    pub fn add_header<H: Header+HeaderFormat>(&mut self, header: H)
        -> Result<(), HeaderError>
    {
        use super::ResponseImpl::*;
        use self::HeaderError::*;
        match self.1 {
            Headers { ref mut content_length, ref mut chunked, .. } => {
                match Any::downcast_ref::<ContentLength>(&header) {
                    Some(&ContentLength(ln)) => {
                        if *chunked {
                            return Err(ContentLengthAfterTransferEncoding);
                        }
                        if content_length.is_some() {
                            return Err(DuplicateContentLength);
                        }
                        *content_length = Some(ln);
                    }
                    None => {}
                }
                match Any::downcast_ref::<TransferEncoding>(&header) {
                    Some(te) if te[..] == [Encoding::Chunked] => {
                        if *chunked {
                            return Err(DuplicateTransferEncoding);
                        }
                        if content_length.is_some() {
                            return Err(TransferEncodingAfterContentLength);
                        }
                        *chunked = true;
                    }
                    Some(_) => {
                        return Err(UnknownTransferEncoding);
                    }
                    None => {}
                }
                write!(self.0, "{}", HeaderFormatter(&header)).unwrap();
                Ok(())
            }
            ref state => {
                panic!("Called add_header() method on response in a state {:?}",
                       state)
            }
        }
    }
    /// Returns true if at least `status()` method has been called
    ///
    /// This is mostly useful to find out whether we can build an error page
    /// or it's already too late.
    pub fn is_started(&self) -> bool {
        !matches!(self.1, ResponseImpl::Start { .. })
    }
    /// Checks the validity of headers. And returns `true` if entity
    /// body is expected.
    ///
    /// Specifically `false` is returned when status is 101, 204, 304 or the
    /// request is HEAD. Which means in both cases where response body is
    /// either ignored (304, HEAD) or is denied by specification. But not
    /// when response is zero-length.
    ///
    /// Similarly to `add_header()` it's fine to `unwrap()` here, unless you're
    /// doing some proxying.
    ///
    /// # Panics
    ///
    /// Panics when response is in a wrong state
    pub fn done_headers(&mut self) -> Result<bool, HeaderError> {
        use super::ResponseBody::*;
        use super::ResponseImpl::*;
        match self.1 {
            Start { .. } => {
                panic!("Trying to send headers, but no response status yet");
            }
            Headers { body: Ignored, .. } => {
                self.1 = IgnoredBody;
                Ok(false)
            }
            Headers { body: Denied, .. } => {
                self.1 = ZeroBodyResponse;
                Ok(false)
            }
            Headers { body: Normal, content_length: Some(cl), chunked: false }
            => {
                self.1 = FixedSizeBody(cl);
                Ok(true)
            }
            Headers { body: Normal, content_length: None, chunked: true } => {
                self.1 = ChunkedBody;
                Ok(true)
            }
            Headers { body: Normal, content_length: Some(_), chunked: true }
            => unreachable!(),
            Headers { body: Normal, content_length: None, chunked: false } => {
                Err(HeaderError::CantDetermineBodySize)
            }
            ref state => {
                panic!("Called done_headers() method on  in a state {:?}",
                       state)
            }
        }
    }
    /// Write a chunk of the body
    ///
    /// Works both for fixed-size body and chunked body.
    ///
    /// For the chunked body each chunk is put into the buffer immediately
    /// prefixed by chunk size.
    ///
    /// For both modes chunk is put into the buffer, but is only sent when
    /// rotor-stream state machine is reached. So you may put multiple chunks
    /// into the buffer quite efficiently.
    ///
    /// For Ignored body you can `write_body` any number of times, it's just
    /// ignored. But it's more efficient to check it with `needs_body()`
    ///
    /// # Panics
    ///
    /// When response is in wrong state. Or there is no headers which
    /// determine response body length (either Content-Length or
    /// Transfer-Encoding)
    pub fn write_body(&mut self, data: &[u8]) {
        use super::ResponseImpl::*;
        match self.1 {
            ZeroBodyResponse => {
                if data.len() != 0 {
                    panic!("Non-zero data length for the response where \
                            the response body is denied (101, 204)");
                }
            }
            FixedSizeBody(ref mut x) => {
                if data.len() as u64 >= *x {
                    panic!("Fixed size response error. \
                        Bytes left {} but got additional {}", x, data.len());
                }
                self.0.write(data).unwrap();
                *x -= data.len() as u64;
            }
            ChunkedBody => {
                write!(self.0, "{:x}\r\n", data.len()).unwrap();
                self.0.write(data).unwrap();
            }
            ref state => {
                panic!("Called write_body() method on response \
                    in a state {:?}", state)
            }
        }
    }
    /// Returns true if `done()` method is already called and everything
    /// was okay.
    pub fn is_complete(&self) -> bool {
        matches!(self.1, ResponseImpl::Done)
    }
    /// Writes needed final finalization data into the buffer and asserts
    /// that response is in the appropriate state for that.
    ///
    /// The method may be called multiple times
    ///
    /// # Panics
    ///
    /// When the response is in the wrong state or when Content-Length bytes
    /// are not written yet
    pub fn done(&mut self) {
        use super::ResponseImpl::*;
        match self.1 {
            ChunkedBody => {
                self.0.write(b"0\r\n").unwrap();
                self.1 = Done;
            }
            FixedSizeBody(0) => {}
            ZeroBodyResponse => {}
            IgnoredBody => {}
            Done => {}  // multiple invocations are okay
            ref state => {
                panic!("Called done() method on response in a state {:?}",
                       state);
            }
        }
    }
}

